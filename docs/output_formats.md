# Output Formats

The output formats generated by the Simple Runtime Analyzer library are designed for both human readability and machine processing, ensuring compatibility with a wide range of analysis tools and visualization systems.

[TOC]

## Format Detection

The library automatically detects the correct output format based on the file extension provided when saving data:

* `.txt` → Plain Text Format
* `.csv` → CSV (Comma-Separated Values) Format
* `.json` → JSON (JavaScript Object Notation) Format

For stream-based reporting using the `generate_report` function, the format can be specified explicitly as a string (`"text"`, `"csv"`, or `"json"`).

-----

## Compatibility

The choice of output format depends on the specific use case. The table below outlines the general compatibility of each format with common data analysis and programming tools.

|  Format  |     Excel     | Python Pandas | JavaScript |      R       |  Database   |
|:--------:|:-------------:|:--------------:|:----------:|:------------:|:-----------:|
| **CSV**  | ✅ Excellent  | ✅ Excellent   | ✅ Good     | ✅ Excellent | ✅ Excellent |
| **JSON** | ⚠️ Fair      | ✅ Excellent   | ✅ Excellent| ✅ Good      | ✅ Excellent |
| **Text** | ⚠️ Poor      | ⚠️ Fair        | ⚠️ Fair     | ⚠️ Fair      | ❌ Poor      |

-----

## Runtime Report Formats

The `runtime_reporter` module generates profiling reports that summarize performance metrics.

### Text Format (.txt) {#txt_format}

This format is optimized for human readability and console output. The data is presented with fixed-width columns for clear alignment.

* **Structure**: `Sample [ID]: | Time: [value] [unit] | Sample size: [size]`.
* **Example**:

    ```txt
    Sample 1: | Time: 150 μs | Sample size: 100
    Sample 2: | Time: 320 μs | Sample size: 200
    Sample 3: | Time: 1 ms | Sample size: 1000
    ```

### CSV Format (.csv) {#csv_format}

This is a machine-readable format optimized for data analysis and spreadsheet applications. It includes a header row for easy data import.

* **Structure**: `sample_id,time_unit,time_value,sample_size`.
* **Example**:

    ```csv
    sample_id,time_unit,time_value,sample_size
    1,μs,150,100
    2,μs,320,200
    3,μs,750,400
    4,ms,1,1000
    5,ms,3,2000
    ```

### JSON Format (.json) {#json_format}

This structured format is ideal for programmatic consumption, such as in web applications or other software. The data is represented as an array of JSON objects, each with distinct keys for clarity.

* **Structure**: An array of objects, where each object contains `"sample_id"`, `"time_unit"`, `"time_value"`, and `"sample_size"`.
* **Example**:

    ```json
    [
      {
        "sample_id": 1,
        "time_unit": "μs",
        "time_value": 150,
        "sample_size": 100
      },
      {
        "sample_id": 2,
        "time_unit": "μs",
        "time_value": 320,
        "sample_size": 200
      }
    ]
    ```

-----

## Sample Data Formats

The `sample_utilities` module can serialize generated test data for later use. The `save_samples` function handles this process, with different output formats for the samples themselves.

### Text Format (.txt)

Each sample is written to a new line in the file. The format is a string representation of the iterable container.

* **Structure**: `[value1, value2, value3, ..., valueN]`.

### CSV Format (.csv)

This format includes a header row and places each sample in a separate line, with the entire sample data quoted to ensure proper CSV parsing.

* **Structure**: `sample_id,sample_data`.
* **Example**:

    ```csv
    sample_id,sample_data
    1,"[value1, value2, value3]"
    2,"[value4, value5, value6]"
    ```

### JSON Format (.json)

This format stores the samples as an array of strings. Each string is the serialized representation of a single sample, with proper JSON escaping for special characters.

* **Handling of Special Characters**: To ensure JSON validity, the library explicitly escapes special characters

```json
    ", \, \b, \f, etc.
```

within the serialized strings.

* **Structure**: An array of strings, where each string is the serialized sample.
* **Example**:

    ```json
    [
      "[value1, value2, value3]",
      "[value4, value5, value6]"
    ]
    ```
